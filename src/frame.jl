struct Resource
  data::Any
  name::Symbol
  persistent::Bool
end

"""
Frame-global structure that holds all data needed in the frame.

Its linear allocator is used for allocating lots of small objects, like material parameters and vertex data.

Other resources that require a global descriptor set (bind-once strategy) are put into a `ResourceDescriptors`.
This includes general image data & samplers, with the corresponding descriptors.

The index list is used to append index data and is turned into an index buffer before initiating the render sequence.
"""
struct GlobalData
  allocator::LinearAllocator
  resources::ResourceDescriptors
  index_list::Vector{UInt32}
  index_buffer::Ref{BufferBlock{MemoryBlock}}
end

GlobalData(device) = GlobalData(
  LinearAllocator(device, 1_000_000), # 1 MB
  ResourceDescriptors(device),
  [],
  Ref{BufferBlock{MemoryBlock}}(),
)

function populate_descriptor_sets!(gd::GlobalData)
  state = gd.resources.gset.state
  types = [Vk.DESCRIPTOR_TYPE_SAMPLED_IMAGE, Vk.DESCRIPTOR_TYPE_STORAGE_IMAGE, Vk.DESCRIPTOR_TYPE_SAMPLER, Vk.DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER]
  writes =
    types |> Enumerate() |> Map() do (i, type)
      infos = state[type]
      !isempty(infos) || return nothing
      Vk.WriteDescriptorSet(gd.resources.gset.set.handle, i - 1, 0, type, infos, [], [])
    end |> Filter(!isnothing) |> collect
  !isempty(writes) || return
  Vk.update_descriptor_sets(
    device(gd.resources.gset.set),
    writes,
    [],
  )
end

function allocate_index_buffer(gd::GlobalData, device::Device)
  gd.index_buffer[] = buffer(device, convert(Vector{UInt32}, gd.index_list .- 1); usage = Vk.BUFFER_USAGE_INDEX_BUFFER_BIT)
end

struct Frame
  resources::Dictionary{Symbol,Resource}
  gd::GlobalData
end

Frame(device) = Frame(Dictionary(), GlobalData(device))

function register(frame::Frame, resource_name::Symbol, resource_data; persistent = true)
  insert!(frame.resources, resource_name, Resource(resource_data, resource_name, persistent))
end

function Base.get(frame::Frame, ::Type{T}, symbol::Symbol) where {T}
  frame.resources[symbol].data::T
end

#=

struct FrameSynchronization
    image_acquired::Vk.Semaphore
    image_rendered::Vk.Semaphore
    has_rendered::Vk.Fence
end

FrameSynchronization(device) = FrameSynchronization(Vk.Semaphore(device), Vk.Semaphore(device), Vk.Fence(device; flags = FENCE_CREATE_SIGNALED_BIT))

struct FrameState
    device::Device
    swapchain::Ref{Swapchain}
    frames::Vector{Frame}
    current_frame::Ref{Frame}
    frame_count::Ref{Int}
    syncs::Dictionary{Frame,FrameSynchronization}
end

device(fs::FrameState) = fs.device

function FrameState(device, swapchain::Swapchain)
    max_in_flight = info(swapchain).min_image_count
    fs = FrameState(device, Ref(swapchain), [], Ref{Frame}(), Ref(0), Dictionary())
    update!(fs)
end

function Vk.SurfaceCapabilitiesKHR(fs::FrameState)
    unwrap(get_physical_device_surface_capabilities_khr(device(fs).physical_device, info(fs.swapchain[]).surface))
end

function recreate_swapchain!(fs::FrameState, new_extent::NTuple{2,Int})
    swapchain = fs.swapchain[]
    swapchain_info = setproperties(info(swapchain), old_swapchain = handle(swapchain), image_extent = Vk.Extent2D(new_extent...))
    swapchain_handle = unwrap(create_swapchain_khr(device(fs), swapchain_info))
    fs.swapchain[] = Created(swapchain_handle, swapchain_info)
    fs
end

function get_frames(fs::FrameState)
    swapchain = fs.swapchain[]
    extent = info(swapchain).image_extent
    map(unwrap(get_swapchain_images_khr(device(fs), swapchain))) do img
        view = View(
            device(fs),
            img,
            IMAGE_VIEW_TYPE_2D,
            info(swapchain).image_format,
            ComponentMapping(fill(COMPONENT_SWIZZLE_IDENTITY, 4)...),
            ImageSubresourceRange(IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1),
        )

        fb = Framebuffer(device(fs), fs.render_pass, [view], extent.width, extent.height, 1)
        Frame(img, view, fb)
    end
end

function update!(fs::FrameState)
    empty!(fs.frames)
    empty!(fs.syncs)

    # TODO: make fields of returned-only structs high-level in Vulkan.jl
    _extent = SurfaceCapabilitiesKHR(fs).current_extent.vks
    new_extent = Extent2D(_extent.width, _extent.height)
    if new_extent â‰  info(fs.swapchain[]).image_extent
        recreate_swapchain!(fs, new_extent)
    end

    append!(fs.frames, get_frames(fs))
    fs.current_frame[] = first(fs.frames)

    foreach(fs.frames) do frame
        insert!(fs.syncs, frame, FrameSynchronization(device(fs.render_pass)))
    end
    fs
end

"""
    command_buffers(frame_state, app)

Command buffers generated by the application.
"""
function command_buffers end

function next_frame!(fs::FrameState, dispatch::QueueDispatch, app)
    swapchain = fs.swapchain[]

    # acquire next image
    image_acquired = fs.syncs[fs.current_frame[]].image_acquired
    status = @timeit to "Acquire next image" acquire_next_image_khr(device(fs), swapchain, typemax(UInt64); semaphore = image_acquired)
    if !iserror(status)
        idx, result = unwrap(status)
        @assert result in (SUCCESS, SUBOPTIMAL_KHR) "$result: Could not retrieve next swapchain image"
        frame = fs.frames[idx + 1]
        sync = fs.syncs[frame]

        # submit rendering commands
        @timeit to "Submit rendering commands" begin
            cbuffs = @timeit to "Create command buffers" command_buffers(fs, app)
            img_acquired_info = SemaphoreSubmitInfoKHR(image_acquired, 0, 0; stage_mask = PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR)
            img_rendered_info = SemaphoreSubmitInfoKHR(sync.has_rendered, 0, 0; stage_mask = PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR)
            render_info = SubmitInfo2KHR([img_acquired_info], CommandBufferSubmitInfoKHR.(cbuffs, 0), [img_rendered_info])
            @timeit to "Wait for frame being rendered" wait_for_fences(device(fs), [sync.has_rendered], false, typemax(UInt64))
            reset_fences(device(fs), [sync.has_rendered])
            submit(dispatch, QUEUE_GRAPHICS_BIT, [render_info]; fence = sync.has_rendered)
        end

        # submit presentation commands
        @timeit to "Submit presentation commands" begin
            present_info = PresentInfoKHR([sync.image_rendered], [swapchain], [idx])
            unwrap(present(dispatch, present_info))
        end

        fs.frame_count[] += 1
        fs.current_frame[] = frame
    else
        err = unwrap_error(status)
        if err.code == ERROR_OUT_OF_DATE_KHR
            # recreate swapchain and start over
            @timeit to "Recreate swapchain" update!(fs)
            next_frame!(fs, rdr, app)
        end
    end
end

function wait_hasrendered(fs::FrameState)
    wait_for_fences(device(fs), getproperty.(fs.syncs, :has_rendered), true, typemax(UInt64))
end

function next_frame!(ctx::FrameContext)
    next_frame!(ctx.state)
    foreach(ctx.pending) do resource
        finalize(resource)
    end
    empty!(ctx.pending)
end

function stage!(ctx::FrameContext, resource)
    push!(ctx.pending, resource)
end

=#
